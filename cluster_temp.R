library (tidyverse)
library (REdaS)
library (factoextra)
library(rgdal)
library(rgeos)
library(adehabitatHR)
library(rgeos)
library(ggmap)
library(ggplot2)
library(terra)
library(sf)
library(units)
library(smoothr)
library(data.table)
library(parallel)
library(doParallel)
library(foreach)

#num_cores <- detectCores()

##cl <- makeCluster(num_cores)
registerDoParallel(cl)

ind <- st_read("India.shp")
pak <- st_read("Pakistan.shp")
nep <- st_read("Nepal.shp")
bhu <- st_read("Bhutan.shp")
ban <- st_read("Bangladesh.shp")
lak <- st_read("SriLanka.shp")
mal <- st_read("Maldives.shp")
sta <- st_read("India States.shp")
cap <- st_read("Capitals.shp")

# Clipping polygon
ind_sub <- st_read("ind_sub_clean_simplified_valid.shp")
ind_sub <- st_make_valid(ind_sub)


assign_cluster <- function(locality_index, locality_matrix, distance, next_cluster, cluster) {
  index <- 1  # Initialize the index to 1
  
  while (index <= ncol(locality_matrix)) {
    if (locality_index != index &&
        is.na(cluster$CLUSTER[index]) &&
        locality_matrix[locality_index, index] <= distance) {
      cluster$CLUSTER[index] <- next_cluster
      locality_index <- index  # Update the locality index for further processing
      index <- 1  # Reset the index to 1 to start from the beginning
    } else {
      index <- index + 1  # Increment the index to move to the next column
    }
  }
  
  return(cluster)
}


CurMonth <- 9
CurYear  <- 2022
# Keep the zip file in a direct one level up as data

# TODO: Move to India Data
ebdfile <- paste0("ebd_IN_prv_rel",month.abb[CurMonth],"-",CurYear)

# List the interested columns
preimp <-  c( 
  "SCIENTIFIC.NAME", # For list length calc.
  "CATEGORY", # Additional protection to remove spuhs
  "OBSERVATION.DATE", # For year and month
  "LATITUDE", #For identifying region
  "LONGITUDE", #For identifying region
  "APPROVED" #Remove unapproved records
)

speciesattr <- read.csv2(paste0("..\\soib_v2\\SoIB_main_09062023.csv"), sep=",") %>% 
                dplyr::select('eBird.Scientific.Name.2022', 'India.Endemic')

colnames(speciesattr) <- c("SCIENTIFIC.NAME", "ENDEMIC")

ebdfile <- paste0("..\\state-of-indias-birds\\soibiucn\\",ebdfile)
# Read the header plus first row
nms <- read.delim( paste0 (ebdfile,".txt"),
                   nrows = 1, 
                   sep = '\t', 
                   header = T, 
                   quote = "", 
                   stringsAsFactors = F, 
                   na.strings = c ("", " ",NA)) 
nms <- names(nms)
nms [!(nms %in% preimp)] <- "NULL"
nms [nms %in% preimp] <- NA

data <- read.delim(paste0(ebdfile,".txt"),
                   colClasses = nms,
                   #                  nrows = 100000, # For testing, this is useful
                   sep = '\t', 
                   header = T, 
                   quote = "", 
                   stringsAsFactors = F, 
                   na.strings = c ("", " ",NA)) 

# Selecting the list of species. Should include all species
data <- data %>% 
            filter (APPROVED == 1) %>%
#              inner_join(speciesattr)
            inner_join(speciesattr %>% filter (ENDEMIC == "Yes"))

species <- data$SCIENTIFIC.NAME %>% unique()

ggplot_list <- list()

# Make the location data more coarse.
loc_table <- data %>% 
                    mutate (LATITUDE = 0.1 * round(10 * LATITUDE),
                            LONGITUDE = 0.1 * round (10 * LONGITUDE),
                            LOCALITY_ID = as.integer (LONGITUDE*100000 + LATITUDE*10),
                            MONTH = as.integer(format(as.Date(OBSERVATION.DATE),"%m")),
                            YEAR = as.integer(format(as.Date(OBSERVATION.DATE),"%Y"))) %>%
                            dplyr::select(SCIENTIFIC.NAME, LOCALITY_ID, MONTH, YEAR) %>% 
                            distinct()

data <- NULL

# Pre-processed location data with measurements betweeen eBird locations. This is generated by a perl/julia script.
eloc <- readRDS("loc.RDS")
setDT(eloc)
setkey(eloc, LOCALITY1, LOCALITY2)

# Go over all the species.
for (i in 1: length(species))
#foreach(i = 1:length(species[1:16]), .packages = c("tidyvers", "rgeos")) %dopar% 
{
   # For each species, find the unique locations
   print(species[i])
  
# Begin create Locality Matrix#######################################  
   spec_loc_table <- loc_table %>% 
                        filter (SCIENTIFIC.NAME == species[i])
   
   localities <- spec_loc_table %>% 
                    distinct(LOCALITY_ID) 
   
   num_localities <- nrow (localities)
   
   print(num_localities)
   
   locality_list = as.integer(localities$LOCALITY_ID) %>% sort()
   
   loc_f <- eloc[LOCALITY1 %in% locality_list & LOCALITY2 %in% locality_list]
   
   loc_f$LOCALITY1 <- as.integer(loc_f$LOCALITY1)
   loc_f$LOCALITY2 <- as.integer(loc_f$LOCALITY2)
   
   # Combine locality values to create row and column names
   locations <- unique(c(loc_f$LOCALITY1, loc_f$LOCALITY2))
   # Generate complete set of row and column indices
   indices <- expand.grid(LOCALITY1 = locations, LOCALITY2 = locations, stringsAsFactors = FALSE) %>% as.data.table()
   
   setDT(loc_f)
   setkey(loc_f, LOCALITY1, LOCALITY2)
   
   # Aggregate distances for the same row and column indices
   aggregated_loc_f <- loc_f[, .(DISTANCE = sum(DISTANCE)), by = .(LOCALITY1, LOCALITY2)]
   
   # Merge with the aggregated data to fill in missing values
   loc_f  <- merge(indices, aggregated_loc_f, by = c("LOCALITY1", "LOCALITY2"), all.x = TRUE)
   
   
   setDT(loc_f)
   setkey(loc_f, LOCALITY1, LOCALITY2)
   
   # Create a locality_matrix
   locality_matrix <- matrix(
     loc_f$DISTANCE,
     nrow = num_localities,  
     ncol = num_localities,        
     byrow = TRUE
   )
   rownames(locality_matrix) = colnames(locality_matrix) = locality_list
   
   # Make the matrix symmetrical.
   missing_values <- is.na(locality_matrix)
   transposed_values <- t(locality_matrix)
   locality_matrix[missing_values] <- transposed_values[missing_values]
   
   print("Saving locatlity matrix")
   saveRDS(locality_matrix, paste0(".\\locality_matrix\\locality_matrix_",species[i],".RDS"))

#  End create Locality Matrix#######################################  
   
   locality_matrix <- readRDS(paste0(".\\locality_matrix\\locality_matrix_",species[i],".RDS"))
  
   
#  Begin create Clusters #######################################  
   
   dist_threshold = 100
   # Now we are going to assign a cluster for every locality. 
   # Initialise the cluster dataframe
   cluster <- data.frame(rownames(locality_matrix))
   cluster$cluster <- NA
   colnames(cluster) <- c("LOCALITY.ID", "CLUSTER")
   # Assign all localities with empty cluster as initialisation. 
   cluster$LOCALITY.ID <- as.integer(cluster$LOCALITY.ID)   
   next_cluster <- 0
   
   # Any locations within 100km will be merged into one
   
   for (locality_index in 1: nrow(locality_matrix))
   { # Iterate over every entry that do not have a cluster and assign a cluster.
     if(is.na(cluster$CLUSTER[locality_index]))
     {
       print(paste0("Loc:",locality_index))
       next_cluster <- next_cluster + 1
       
#       index <- 1  # Initialize the index to 1
       
#       while (index <= ncol(locality_matrix)) {
#         if (locality_index != index &&
#             is.na(cluster$CLUSTER[index]) &&
#             locality_matrix[locality_index, index] <= dist_threshold) {
#           cluster$CLUSTER[index] <- next_cluster
#           locality_index <- index  # Update the locality index for further processing
#           index <- 1  # Reset the index to 1 to start from the beginning
#         } else {
#           index <- index + 1  # Increment the index to move to the next column
#         }
#       }
       
       cluster <- assign_cluster (locality_index, locality_matrix, dist_threshold, next_cluster, cluster)
       print(paste(cluster$CLUSTER[52], cluster$CLUSTER[70], cluster$CLUSTER[72]))
     }
   }
   
   # We cant have polygons with two points. Plot them as just points.
   cluster <- cluster %>%
     group_by(CLUSTER) %>%
     mutate(CLUSTER = ifelse(n() < 3, NA, CLUSTER)) %>%
     ungroup()    
   
   print("Saving clusters")
   saveRDS(cluster, paste0(".\\clusters\\cluster_",species[i],".RDS"))
   cluster <- readRDS(paste0(".\\clusters\\cluster_",species[i],".RDS"))
   
   
   
    # Create a loc3 with only the latitude and longitude of the localities in the cluster dataframe  
    loc3 <- cluster %>% 
            inner_join(spec_loc_table, by = c("LOCALITY.ID" = "LOCALITY_ID")) %>% 
            mutate(LATITUDE = (LOCALITY.ID - 10000 * as.integer(LOCALITY.ID/10000))/10,
                   LONGITUDE = as.integer(LOCALITY.ID/10000)/10) %>%
            dplyr::select(LATITUDE, LONGITUDE) %>%
            distinct()
    
    if(nrow(loc3) < 5)
    {
      loc3 <- loc3 %>% 
                add_row(LATITUDE = loc3$LATITUDE[1] - 0.1, LONGITUDE = loc3$LONGITUDE[1] - 0.1) %>% 
                add_row(LATITUDE = loc3$LATITUDE[1] - 0.1, LONGITUDE = loc3$LONGITUDE[1] + 0.1) %>% 
                add_row(LATITUDE = loc3$LATITUDE[1] + 0.1, LONGITUDE = loc3$LONGITUDE[1] - 0.1) %>% 
                add_row(LATITUDE = loc3$LATITUDE[1] + 0.1, LONGITUDE = loc3$LONGITUDE[1] + 0.1)
    }
    # Convert it into a spatial dataframe
    sp::coordinates(loc3) <- ~LONGITUDE+LATITUDE
    
    #Calculate MCP
    mcp_species <- mcp(loc3, percent=100, unout="km2")
    
    #Pick bounding square and convert to form usable in maps
    bounds <- bbox(mcp_species)


    gdisplay <- ggplot()
    gdisplay <- gdisplay + geom_sf(data=pak, fill = "transparent")  
    gdisplay <- gdisplay + geom_sf(data=nep, fill = "transparent")  
    gdisplay <- gdisplay + geom_sf(data=bhu, fill = "transparent")  
    gdisplay <- gdisplay + geom_sf(data=ban, fill = "transparent")  
    gdisplay <- gdisplay + geom_sf(data=lak, fill = "transparent")  
    gdisplay <- gdisplay + geom_sf(data=mal, fill = "transparent")  
    gdisplay <- gdisplay + geom_sf(data=sta, linetype = "dashed", fill = "transparent")
    gdisplay <- gdisplay + geom_sf(data=ind, fill = "transparent")  
#    gdisplay <- gdisplay + coord_sf(xlim = c(bounds[1] - 1, bounds[3] + 1), ylim = c(bounds[2] - 1, bounds[4] + 1))  
    gdisplay <- gdisplay + theme_void() +
                  theme(plot.background = element_rect(fill = "transparent", color = NA),
                  panel.grid.major = element_blank(),
                  panel.grid.minor = element_blank(),
                  panel.border = element_blank(),
                  axis.text = element_blank(),
                  axis.title = element_blank())
    
    clusters <- cluster$CLUSTER %>% unique()
    
    # Iterate over the clusters
    for (j in clusters)  
    {
      if(!is.na(clusters[j]))
      {
        loc3 <- cluster %>% 
                  filter (CLUSTER == j) %>% 
                  inner_join(spec_loc_table, by = c("LOCALITY.ID" = "LOCALITY_ID")) %>% 
                  mutate(LATITUDE = (LOCALITY.ID - 10000 * as.integer(LOCALITY.ID/10000))/10,
                         LONGITUDE = as.integer(LOCALITY.ID/10000)/10) %>%
                  dplyr::select(LATITUDE, LONGITUDE) %>%
                  distinct()
    
        sp::coordinates(loc3) <- ~LONGITUDE+LATITUDE
    
        CH = gConvexHull(loc3)
        
        r_poly_smooth <- smooth(CH, method = "chaikin")
        
        # Clipping the polygon to the landmass for land birds
#        clipped_r_poly_smooth <- st_as_sf(r_poly_smooth, coords = c("long", "lat"))
#        st_crs(clipped_r_poly_smooth) <- st_crs(ind_sub)
#        clipped_r_poly_smooth <- st_transform(clipped_r_poly_smooth, crs = st_crs(ind_sub))
#        clipped_r_poly_smooth <- st_intersection(clipped_r_poly_smooth, ind_sub)
        
        gdisplay <- gdisplay +
                    geom_polygon(data=fortify(r_poly_smooth), aes(x=long, y=lat, group=group), fill = "darkgreen", alpha=0.5, linewidth = 0) 
      }
    }
    
      
    clusterNA <- cluster %>% 
                      filter (is.na(CLUSTER)) %>%
                      mutate(LATITUDE = (LOCALITY.ID - 10000 * as.integer(LOCALITY.ID/10000))/10,
                             LONGITUDE = as.integer(LOCALITY.ID/10000)/10) %>% 
                             dplyr::select(LATITUDE, LONGITUDE)
    gdisplay <- gdisplay + 
                geom_point(data = fortify(clusterNA), aes(x=LONGITUDE, y=LATITUDE), shape = 1, color="darkgreen", fill = "transparent", size = 1) + 
                geom_point(data = cap, aes(x=LONGITUDE, y=LATITUDE), shape = 15, color = "black", fill = "black", size = 1) 
    
      
    gdisplay <- gdisplay + 
                theme(legend.position = "none")
    
#    ggsave(paste0(".\\maps\\map_compare", species[i],".jpg"), gdisplay)
    
    ggplot_list[[species[i]]] <- gdisplay

#   Save space
    gdisplay <- NULL
    locality_matrix <- NULL
    loc3 <- NULL
    cluster <- NULL
#   stopCluster(cl)
}


for (i in 1: length(ggplot_list))
{
  ggsave(filename = paste0(".\\maps\\map_", names(ggplot_list)[i],".jpg"), plot = ggplot_list[[i]],
         width = 1871, height = 1384, units = "px")
  
           
}


